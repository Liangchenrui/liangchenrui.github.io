<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>AI Agent-意图识别调研 | lcr&#39;s blog | Stay hungry. Stay foolish</title>

  
  <meta name="author" content="Liang Chenrui">
  

  
  <meta name="description" content="personal blog">
  

  
  
  <meta name="keywords" content="Agent,调研">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="AI Agent-意图识别调研"/>

  <meta property="og:site_name" content="lcr&#39;s blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="lcr&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">lcr&#39;s blog</a>
    </h1>
    <p class="site-description">Stay hungry. Stay foolish</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>AI Agent-意图识别调研</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2025/11/06/AI-Agent：意图识别调研/" rel="bookmark">
        <time class="entry-date published" datetime="2025-11-06T07:21:14.000Z">
          2025-11-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>如何将用户输入映射到预定义的意图类别，如直接调用大模型、联网搜索、工具调用？</p>
<span id="more"></span>

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>区分两种不同类型的意图识别：</p>
<ul>
<li><strong>系统路由型意图识别</strong>（或称<strong>语义路由</strong>）：对话系统首先判断用户请求应由哪种处理模块来响应，如直接让大语言模型回答、调用搜索引擎检索、或者调用某个特定工具来处理。其核心目标是<strong>路由</strong>：将用户的自然语言查询分发到最合适的子系统或知识源，从而获得最优的答案。</li>
<li><strong>任务导向型意图识别</strong>是传统任务型对话中的概念，其目的是判断用户的具体目标或意图类别，例如用户想“预订航班”还是“查询天气”等。这种识别往往发生在对话的自然语言理解模块，用于将用户语句映射到预定义的任务类别，并识别所需的槽位信息。</li>
</ul>
<p>本次调研针对的任务场景是：</p>
<ul>
<li>分类任务：将用户输入映射到预定义的意图类别（直接调用大模型、联网搜索、工具调用）</li>
</ul>
<h1 id="2-主流方法"><a href="#2-主流方法" class="headerlink" title="2 主流方法"></a>2 主流方法</h1><h2 id="2-1-规则匹配"><a href="#2-1-规则匹配" class="headerlink" title="2.1 规则匹配"></a>2.1 规则匹配</h2><p>简单地依据关键词或模式判断。如包含关键词“新闻”就路由到“联网搜索”。</p>
<h2 id="2-2-监督分类器"><a href="#2-2-监督分类器" class="headerlink" title="2.2 监督分类器"></a>2.2 监督分类器</h2><p>传统上（2023年及以前），意图检测系统是使用有监督分类或基于相似性的模型构建的。<br>先用标注数据训练分类模型对意图进行预测，然后根据预测结果路由。</p>
<h3 id="SetFit（Sentence-Transformer-Fine-tuning）-2022-09-22"><a href="#SetFit（Sentence-Transformer-Fine-tuning）-2022-09-22" class="headerlink" title="SetFit（Sentence Transformer Fine-tuning）(2022.09.22)"></a><strong>SetFit（Sentence Transformer Fine-tuning）(2022.09.22)</strong></h3><p>两阶段训练过程：</p>
<ol>
<li>首先在少量标注样例 (典型值是每类 8 个或 16 个样例) 上微调一个 Sentence Transformer 模型。</li>
<li>然后用微调得到的 Sentence Tranformer 的模型生成文本的嵌入 (embedding) ，并用这些嵌入训练一个分类头 (classification head) 。<br><img src="https://liangchenrui.oss-cn-beijing.aliyuncs.com/obsidian/20251107141630766.PNG" alt="1280X1280.PNG"></li>
</ol>
<p>SetFit 仅需8个样本(few-shot learing)即可达到与在全量数据（3k个样本）微调RoBERTa Large相当的准确度，且训练和推理速度快得多。此外，还有传统的BERT&#x2F;XLNet微调方法，以及LSTM+注意力等。</p>
<p><img src="https://liangchenrui.oss-cn-beijing.aliyuncs.com/obsidian/20251107141711666.PNG" alt="1280X1280 (1).PNG"></p>
<p>RAFT 排行榜上表现突出的方法 (截至 2022 年 9 月)：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Rank</td>
<td>Method</td>
<td>Accuracy</td>
<td>Model Size</td>
</tr>
<tr>
<td>2</td>
<td>T-Few</td>
<td>75.8</td>
<td>11B</td>
</tr>
<tr>
<td>4</td>
<td>Human Baseline</td>
<td>73.5</td>
<td>N&#x2F;A</td>
</tr>
<tr>
<td>6</td>
<td>SetFit (Roberta Large)</td>
<td>71.3</td>
<td>355M</td>
</tr>
<tr>
<td>9</td>
<td>PET</td>
<td>69.6</td>
<td>235M</td>
</tr>
<tr>
<td>11</td>
<td>SetFit (MP-Net)</td>
<td>66.9</td>
<td>110M</td>
</tr>
<tr>
<td>12</td>
<td>GPT-3</td>
<td>62.7</td>
<td>175 B</td>
</tr>
</tbody></table>
<p>无需提示词、训练快、调用成本低，在二分类小样本任务尤其强。</p>
<h3 id="ModernBERT-分类器"><a href="#ModernBERT-分类器" class="headerlink" title="ModernBERT 分类器"></a>ModernBERT 分类器</h3><p>《When to Reason: Semantic Router for vLLM》（2025.10.09）</p>
<ul>
<li><strong>vLLM</strong>：LLM 的推理和服务引擎，可以加速和优化现有 LLM 的推理过程。</li>
<li>工作流程：用户输入被编码器转化成语义向量，通过监督分类器（一个完全微调的 Transformer 网络）将向量分类为简单查询型或推理密集型。</li>
<li>训练模式：全监督&#x2F;传统微调 (Full Supervised Fine-tuning)</li>
<li>模型架构：BERT-Style Cross-Encoder (Encoder-Only)</li>
<li>数据集：<ul>
<li>MMLU-Pro (Multi-task Language Understanding - Professional)：用于意图分类器的训练和最终系统的评测 。它包含大约 12,000 个跨越约 14 个领域的学术样本。</li>
<li>Microsoft Presidio：包含约 50,000 个 Token 级别的 PII（个人身份信息）示例，用于意图分类器的训练。</li>
<li>Jailbreak Security Datasets：用于意图分类器的训练，以增强其对安全相关的分类能力。</li>
</ul>
</li>
<li>评测结果：使用 Qwen&#x2F;Qwen3-30B-A3B 模型在 vLLM v0.10.1 上进行。语义路由器在 MMLU-Pro 上的整体准确率提高了 10.24 个百分点，同时将延迟和 Token 消耗降低了近 50%。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>方法 (Method)</td>
<td>平均准确率 (Avg. Accuracy)</td>
<td>平均延迟 (Avg. Latency, s)</td>
<td>平均 Tokens (Avg. Tokens)</td>
</tr>
<tr>
<td>语义路由器 (Semantic Router)</td>
<td>58.57% [cite: 137]</td>
<td>13.09 [cite: 137]</td>
<td>887.5 [cite: 137]</td>
</tr>
<tr>
<td>直接 vLLM (Direct VLLM)</td>
<td>48.33% [cite: 137]</td>
<td>24.76 [cite: 137]</td>
<td>1,722.1 [cite: 137]</td>
</tr>
<tr>
<td>提升幅度 (Improvement)</td>
<td>+10.24pp (百分点) [cite: 137]</td>
<td>-47.1% [cite: 137]</td>
<td>-48.5% [cite: 137]</td>
</tr>
</tbody></table>
<p>两种模型的对比：</p>
<table>
<thead>
<tr>
<th>方面</th>
<th>SetFit</th>
<th>ModernBERT</th>
</tr>
</thead>
<tbody><tr>
<td>实现目标</td>
<td>高效的少样本学习（Few-Shot Learning）。</td>
<td>高性能、高准确率的全监督分类。</td>
</tr>
<tr>
<td>实现方法</td>
<td>解耦：微调嵌入模型 + 训练线性分类器。</td>
<td>耦合：端到端微调整个 Transformer 编码器。</td>
</tr>
<tr>
<td>规模与效率</td>
<td>分类头极小（线性模型），推理速度快，适合资源有限或快速迭代。</td>
<td>分类头深度耦合于庞大的 Transformer 结构，推理准确性高，适合对精度要求极高的生产环境。</td>
</tr>
</tbody></table>
<h2 id="2-3-向量语义路由"><a href="#2-3-向量语义路由" class="headerlink" title="2.3 向量语义路由"></a>2.3 向量语义路由</h2><p>预先为每种路由定义示例句，将用户查询编码为向量，与示例向量比对，选择最近邻路由。</p>
<p>非常适用于有一组确定的意图类别，并且需要极快的路由和极高的吞吐量的场景。</p>
<h3 id="开源项目-semantic-router（Github-star-2-9k）"><a href="#开源项目-semantic-router（Github-star-2-9k）" class="headerlink" title="开源项目 semantic-router（Github star 2.9k）"></a><strong>开源项目</strong> <a target="_blank" rel="noopener" href="https://github.com/aurelio-labs/semantic-router">semantic-router</a><strong>（Github star 2.9k）</strong></h3><p>将用户输入和预先定义的路由描述（或“语料”）转换为向量嵌入，然后计算相似度。</p>
<p>流程：</p>
<ol>
<li>定义路由和示例提示</li>
<li>将它们加载到 <code>RouteLayer</code> 。</li>
<li>然后在运行时调用 <code>RouteLayer.route(query)</code> 获取最佳匹配的路由名称。</li>
</ol>
<ul>
<li>优点：引入便捷、路由快速。一旦路由向量预先计算好，对新查询进行分类只需快速查找嵌入向量，非常适合高吞吐量或低延迟的需求。</li>
<li>缺点：需要为每个意图准备代表性语句。其准确性取决于这些示例对查询变化的捕捉程度。如果用户的措辞与所有示例相差甚远，路由器可能会错误路由。此外，语义路由是静态类别；处理动态或嵌套意图可能更加困难。</li>
<li>在实践中，许多团队对领域中稳定、定义明确的部分使用语义路由，而对任何“其他”或未分类的内容则回退到 LLM 或默认代理。</li>
</ul>
<h3 id="Langchain-EmbeddingRouterChain"><a href="#Langchain-EmbeddingRouterChain" class="headerlink" title="Langchain.EmbeddingRouterChain"></a>Langchain.EmbeddingRouterChain</h3><p>Langchain 提供了<code>EmbeddingRouterChain</code> ，用向量搜索做路由。<br>首先定义所有意图的“名称+描述”对，并用句子嵌入模型编码到内存向量库；用户输入的文本经同一嵌入模型编码后，与库中意图嵌入做相似度检索，选择相似度最高的意图对应的下游Chain。</p>
<h2 id="2-4-提示词驱动"><a href="#2-4-提示词驱动" class="headerlink" title="2.4 提示词驱动"></a>2.4 提示词驱动</h2><ul>
<li><p>《Intent Detection in the Age of LLMs》（2024.10.02）：使用大模型的自适应上下文学习（adaptive in-context learning, ICL）和思维链（chain-of-thought, CoT）提示法改进意图识别。与通过对比微调设定的句向量分类器 SetFit 模型相比，预测质量和延迟方面的表现更优。</p>
<ul>
<li><strong>自适应ICL</strong>：系统会将在推理阶段收到的用户查询与一个向量数据库中的训练查询嵌入进行比较，然后检索 k 个最相似的查询作为 ICL 示例，这些示例随后被用来构建 LLM 的提示，以帮助 LLM 更好地检测新查询的意图。（提供示例教模型）(GPT-3)</li>
<li><strong>CoT</strong>：一种提示技术。给 LLM 的提示中包含一条指令，要求它在给出最终答案之前先”生成你的推理”（Generate your reasoning before…）。这种方法促使 LLM 在输出最终的“预测意图” 之前，先一步一步地生成其思考过程，从而提高其准确性。（引导模型生成推理过程）<br><img src="https://liangchenrui.oss-cn-beijing.aliyuncs.com/obsidian/20251107141739163.png" alt="bbfdde10-8d81-4c70-a4a9-6464ab4b62c0.png"></li>
</ul>
</li>
<li><p>LangChain提供了 <code>LLMRouterChain</code> ，用 LLM 做路由；</p>
</li>
</ul>
<h2 id="2-5-混合策略"><a href="#2-5-混合策略" class="headerlink" title="2.5 混合策略"></a>2.5 混合策略</h2><ul>
<li>《Intent Detection in the Age of LLMs》进一步提出混合系统（SetFit+LLM）：<ul>
<li>用户查询先被送到SetFit模型，该模型通过微调来执行分类任务，非提示词驱动。</li>
<li>采用基于不确定性（蒙特卡洛 Dropout）的路由策略，在SetFit不确定时，调用LLM（使用自适应ICL+CoT）进行意图检测。<br>评测结果：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法类别</th>
<th>最佳代表模型 (或配置)</th>
<th>平均 F1 Score</th>
<th>平均 p50 延迟 (s)</th>
<th>OOS Recall (范围外召回)</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td>LLMs</td>
<td>Claude v3 Haiku</td>
<td>0.736</td>
<td>1.697</td>
<td>论文指出 OOS Recall 表现普遍较差</td>
<td>在预测准确性（F1 Score）上表现最优，但推理延迟最高，泛化能力强于 SetFit。</td>
</tr>
<tr>
<td>SetFit</td>
<td>SetFit + Neg Aug (SNA)</td>
<td>0.658</td>
<td>0.03</td>
<td>具有极低的延迟（比 LLM 快约 56 倍），通过负样本增强（Neg Aug）性能得到显著提升，但泛化能力相对较弱。</td>
<td></td>
</tr>
<tr>
<td>混合系统</td>
<td>SetFit + Neg Aug + LLM (通过不确定性路由)</td>
<td>接近 LLM 性能</td>
<td>降低 50%</td>
<td>实现了性能和效率的最佳权衡，在保持接近 LLM 准确度的同时，将延迟降低了一半。</td>
<td></td>
</tr>
<tr>
<td>即混合系统可在近似不损失准确率的前提下，显著降低 50%以上的计算延迟。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>AWS 提出 LLM 辅助路由（LLM-assisted routing） + 语义路由（Semantic routing），使用语义搜索进行初步的广泛分类或领域匹配，然后使用 LLM 在这些广泛类别中进行更细粒度的分类。</li>
</ul>
<h2 id="2-6-横向对比"><a href="#2-6-横向对比" class="headerlink" title="2.6 横向对比"></a>2.6 横向对比</h2><table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
<th>最佳使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>规则匹配</td>
<td>快、可解释、无推理成本</td>
<td>维护难、覆盖差、语义弱</td>
<td>小规模、确定性业务</td>
</tr>
<tr>
<td>监督分类器</td>
<td>高准确、低延迟、少样本可用</td>
<td>新意图需重训、泛化差</td>
<td>稳定系统主路由</td>
</tr>
<tr>
<td>语义向量路由</td>
<td>扩展灵活、零样本支持、吞吐高</td>
<td>精度依赖embedding、边界模糊</td>
<td>工具&#x2F;API分发，多意图</td>
</tr>
<tr>
<td>LLM提示词</td>
<td>精度最高、处理复杂语义强</td>
<td>成本高、延迟高、不稳定</td>
<td>困难&#x2F;长尾意图兜底</td>
</tr>
<tr>
<td>混合策略</td>
<td>性价比最高、性能稳健</td>
<td>系统更复杂</td>
<td>生产级最佳实践</td>
</tr>
</tbody></table>
<h1 id="3-企业应用"><a href="#3-企业应用" class="headerlink" title="3 企业应用"></a>3 企业应用</h1><h2 id="3-1-Anthropic-Claude"><a href="#3-1-Anthropic-Claude" class="headerlink" title="3.1 Anthropic Claude"></a>3.1 Anthropic Claude</h2><p>倾向于先使用基于模型推理的“agentic search”，必要时才用检索。</p>
<blockquote>
<p>语义搜索通常比代理搜索更快，但准确性较低、维护难度较大且透明度较低。它涉及将相关上下文“分块”，将这些分块嵌入为向量，然后通过查询这些向量来搜索概念。鉴于其局限性，我们建议先从代理搜索开始，仅在需要更快的结果或更多变体时才添加语义搜索。</p>
</blockquote>
<h2 id="3-2-Google-Gemini"><a href="#3-2-Google-Gemini" class="headerlink" title="3.2 Google Gemini"></a>3.2 Google Gemini</h2><p>通过 <strong>Function Calling</strong> 增强意图识别。Function Calling 本质上是一种结构化的输出格式。</p>
<ul>
<li>清晰的意图边界：向LLM提供清晰的函数签名和描述，要求LLM返回的意图标签是具体的函数名。提供了结构化和高保真度的 ICL 样本。</li>
<li>双重约束：<ul>
<li>意图识别（选择函数）</li>
<li>槽位填充（提取参数）</li>
</ul>
</li>
<li>输出是结构化的 JSON 对象，而非自然语言。将意图识别的结果从“意图标签”提升到“可执行的指令”。</li>
</ul>
<p><img src="https://liangchenrui.oss-cn-beijing.aliyuncs.com/obsidian/20251107141757324.png" alt="32718bdf-f173-4667-b1ac-b11a5ee8a420.png"></p>
<p>参考资料：</p>
<blockquote>
<ol>
<li>Setfit <a target="_blank" rel="noopener" href="https://github.com/huggingface/setfit">https://github.com/huggingface/setfit</a></li>
<li>Efficient Few-Shot Learning Without Prompts <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2209.11055">http://arxiv.org/abs/2209.11055</a></li>
<li>SetFit: 高效的无提示少样本学习 <a target="_blank" rel="noopener" href="https://huggingface.co/blog/zh/setfit">https://huggingface.co/blog/zh/setfit</a></li>
<li>When to Reason: Semantic Router for vLLM <a target="_blank" rel="noopener" href="http://arxiv.org/abs/2510.08731">http://arxiv.org/abs/2510.08731</a></li>
<li>Intent Recognition and Auto‑Routing in Multi-Agent Systems <a target="_blank" rel="noopener" href="https://gist.github.com/mkbctrl/a35764e99fe0c8e8c00b2358f55cd7fa">https://gist.github.com/mkbctrl/a35764e99fe0c8e8c00b2358f55cd7fa</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/aurelio-labs/semantic-router">semantic-router</a></li>
<li>Intent Detection in the Age of LLMs <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2410.01627v1">https://arxiv.org/abs/2410.01627v1</a></li>
<li>Multi-LLM routing strategies for generative AI applications on AWS <a target="_blank" rel="noopener" href="https://aws.amazon.com/cn/blogs/machine-learning/multi-llm-routing-strategies-for-generative-ai-applications-on-aws/#:~:text=">https://aws.amazon.com/cn/blogs/machine-learning/multi-llm-routing-strategies-for-generative-ai-applications-on-aws/#:~:text=</a></li>
<li>Building agents with the Claude Agent SDK <a target="_blank" rel="noopener" href="https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk">https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk</a></li>
<li>Function calling with the Gemini API <a target="_blank" rel="noopener" href="https://ai.google.dev/gemini-api/docs/function-calling?example=meeting#how-it-works">https://ai.google.dev/gemini-api/docs/function-calling?example=meeting#how-it-works</a></li>
</ol>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Agent/">Agent</a><a href="/tags/调研/">调研</a>
    </span>
    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2025 Liang Chenrui
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>